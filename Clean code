Clean code

命名规范
1.  名副其实
2.  避免误导
3. 做有意义的区分
4. 使用读得出来的名称
5. 使用可搜索的名称
6. 避免使用编码
7. 避免思维映射
8. 类名（不应当是动词）
9. 方法名（应当是动词或者动词短语）
10. 别扮可爱
11. 每个概念对应一个词
12. 别用双关语
13. 使用解决方案领域名称
14. 使用源自所涉问题领域的名称
15. 添加有意义的语境
16. 不要添加没用的语境

函数
1.  短小。20行
2.  只做一件事
3.  每个函数一个抽象层级
4. switch语句
5. 使用描述性的名称
6. 函数参数
7. 无副作用
8. 分隔指令与询问
9. 使用异常替代返回错误码
10. 别重复自己（DRY原则）
11. 结构化编程

类
1. 类的组织（封装）
2. 类应该短小
    * 单一权责原则
    * 内聚
    * 保持内聚性就会得到许多短小的类
3. 为了修改而组织

注释
* 不恰当的信息
* 废弃的注释
* 冗余注释
* 糟糕的注释
* 注释掉的代码
环境
* 需要多步才能实现的构建
* 需要多步才能做到的测试
函数
* 过多的参数（没有最好，一个次之，两个、三个再次之，三个以上避免）
* 输出参数
* 标识参数
* 死函数
一般性问题
* 一个源文件中存在多种语言
* 明显的行为未被实现
* 不正确的边界行为
* 忽视安全
* 重复
* 在错误的抽象层级上的代码
* 基于依赖于派生类
* 信息过多
* 死代码
* 垂直分隔(变量和函数应该在靠近被使用的地方定义)
* 前后不一致
* 混淆视听
* 人为耦合
* 特性依赖
* 选择算子参数
* 晦涩的意图
* 位置错误的权责
* 不恰当的静态方法
* 使用解释性变量
* 函数名称应该表达其行为
* 理解算法
* 把逻辑依赖改为物理依赖
* 用多态代替 if/else  或 switch/case
* 遵循标准约定
* 用命名常量替代魔术数
* 准确
* 结构甚于约定
* 封装条件
* 避免否定性条件
* 函数只该做一件事
* 掩蔽时序耦合
* 别随意
* 封装边界条件
* 行数应该只在一个抽象层级上
* 在较高层级放置可配置数据
* 避免传递浏览

名称
* 采用描述性名称
* 名称应与抽象层级相符
* 尽可能使用标准命名法
* 无歧义的名称
* 为较大作用范围选用较长名称
* 避免编码
* 名称应该说明副作用（如：createOrReturnOos）

测试
* 测试不足
* 使用覆盖率工具
* 别略过小测试
* 被忽略的测试就是对不确定食物的疑问
* 测试边界条件
* 全面测试相近的缺陷
* 测试失败的模式有启发性‘
* 测试覆盖率的模式有启发性’
* 测试应该快速



测试遵循的原则
1. 快速
2. 独立
3. 可重复
4. 自足验证
5. 及时

服务器端的权责（在process函数中）
1. 套接字链接管理
2. 客户端处理
3. 线程策略
4. 服务器关闭策略

死锁发生的4个条件
1. 互斥
2. 上锁及等待‘
3. 无抢先机制
4. 循环等待
